1. Need to determine what to rotate

2. Consider cube 9
a. It's position (1, 1, 0)
b. moving it to the left would require a model rotation.

3. Consider the cube in its neutral position

4. Any lateral rotation does not require a model rotation

5. All horizontal rotations require a model rotation

6. There are three states the cube needs to rotate into to display every transformation

7. Each cube face has four directions it can go

8. Check the subsequent cubeface in that direction --
 is it a sibling element? If so, you can rotate for free. (ish)

9.If not, determine one of the two rotations -- how? 

10. Basically, check the "rotation direction" .. of which there are 3 per axis, so 9 things

11. I can rule out one (if I can figure out how) leaving only the target

12. It's always "one" of the things for each thing so I could just memoize them

a. topswizzle --> firstMutation 
b. firstMutation --> tops

13. Put all the faces into three groups. 

14. Now, we know the following

a. The group (two faces)

b. The direction  (up, down , etc);

c. We know the current model rotation

d. We know the east/west are fine, north is a rotation to firstMutation

e. So we just do the logic for each group i dont see a simpler way

NewDay:  rotateModel90X(); When dragged south, achieves the rotation I want towards the user
//rotate model90x turns it "right"

11. Process of animation

a. Mousemove triggers animateDelegator() function

b. animateDelegator() function may trigger a hard rotation rotateModel90X();

c. The rotateModel function will trigger a model change, and useEffect() is called

d. useEffect() has no animations to play yet, so it does the following
    1. Remaps all the colors for the model.
    2. Re-orients the model for the animation
    3. calls dispatchRotateEvent(); 

e. dispatchRotateEvent 
1. uses state information from the target div to trigger an animation.
2. Sets up a delayed listener that then mutates the model by applying the rotations
associated with the animation. 
3. This triggers useEffect()

f. the useEffect() is triggered by the model change
1. resets the animation class state 
2. repaints the model so its consistent

So, I think I need to get into the setTimeout and change the model exactly once.

1. Upside down issues

a. P1
N-->N
E-->E
S-->S 
W-->W

b. P2
N -->E 
E --> S
S --> W
W --> N

c. P3
N --> S
E --> W
S --> N
W --> E

c P4
N --> W
E --> N
S --> E
W --> S

1. TODO list

a. Better user input (longer dashes)

- xChange and yChange

determine which changed more with Math.abs (gives you n-s, or w-e)
determine if they're negative or positive (n-s or w-e)


b. Lockout during animation, allow some time to recolor before user can  input again

c. Fix mousedown issue when rotating (i think this is causing some real issues)

d. Investigate lag 

e. General refactoring

f. Investigate further styling

g. Auto solver? Random initializer

h. Deploy


Issue with mousedown 

a. New idea

b. Mousedown goes down

c. Now, mouseover initializes some original co-ordinates

d. On mouserelease, fire the direction calculator and animation.

1. Randomize the cube color faces logically.

Spam click bug

1. I click down on the cube

a. mousedown becomes true
b. Now, in mousemoving, if the "calcutingRef" is false, it sets the original co-ordinates
c. On release
